<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Hand Tracking dengan Tampilan Tangan</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>
<body style="margin:0;">

<!-- Pilih kamera -->
<div style="position:fixed;top:10px;left:10px;z-index:10;background:#fff;padding:5px;">
  <label for="cameraSelect">Pilih Kamera:</label>
  <select id="cameraSelect"></select>
</div>

<!-- A-Frame scene -->
<a-scene>
  <a-box id="box" position="0 1.5 -3" color="red"></a-box>
  <a-sky color="#ECECEC"></a-sky>
</a-scene>

<!-- Hidden video untuk input kamera -->
<video id="input_video" autoplay playsinline style="display:none;"></video>

<!-- Canvas untuk menampilkan tangan -->
<canvas id="output_canvas" 
        style="position:fixed;bottom:10px;right:10px;width:320px;height:240px;
               border:2px solid black;z-index:20;"></canvas>

<script>
  const boxEl = document.querySelector('#box');
  const videoElement = document.getElementById('input_video');
  const outputCanvas = document.getElementById('output_canvas');
  const ctx = outputCanvas.getContext('2d');
  const cameraSelect = document.getElementById('cameraSelect');

  // MediaPipe Hands
  const hands = new Hands({
    locateFile: (file) => {
      return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }
  });
  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7
  });

  hands.onResults(results => {
    // Gambar ulang canvas
    ctx.save();
    ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
    ctx.drawImage(results.image, 0, 0, outputCanvas.width, outputCanvas.height);

    if (results.multiHandLandmarks) {
      for (const landmarks of results.multiHandLandmarks) {
        // gambar titik2
        drawConnectors(ctx, landmarks, HAND_CONNECTIONS,
          {color: '#00FF00', lineWidth: 2});
        drawLandmarks(ctx, landmarks, {color: '#FF0000', lineWidth: 1});

        // pindahkan box di scene
        const fingertip = landmarks[8];
        const x = (fingertip.x - 0.5) * 4;
        const y = (0.5 - fingertip.y) * 3 + 1.5;
        boxEl.setAttribute('position', `${x} ${y} -3`);
      }
    }
    ctx.restore();
  });

  // ====== Kamera ======
  async function listCameras() {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const videoDevices = devices.filter(d => d.kind === 'videoinput');

    cameraSelect.innerHTML = '';
    videoDevices.forEach((device, idx) => {
      const option = document.createElement('option');
      option.value = device.deviceId;
      option.text = device.label || `Camera ${idx+1}`;
      cameraSelect.appendChild(option);
    });

    let backCam = videoDevices.find(d => 
      d.label.toLowerCase().includes("back") || 
      d.label.toLowerCase().includes("rear") || 
      d.label.toLowerCase().includes("environment")
    );

    if (backCam) {
      cameraSelect.value = backCam.deviceId;
      startCamera(backCam.deviceId);
    } else if (videoDevices.length > 0) {
      cameraSelect.value = videoDevices[0].deviceId;
      startCamera(videoDevices[0].deviceId);
    }
  }

  async function startCamera(deviceId) {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { deviceId: { exact: deviceId }, width: 640, height: 480 }
    });
    videoElement.srcObject = stream;

    async function processFrame() {
      await hands.send({ image: videoElement });
      requestAnimationFrame(processFrame);
    }
    processFrame();
  }

  cameraSelect.addEventListener('change', () => {
    startCamera(cameraSelect.value);
  });

  listCameras();
</script>

</body>
</html>
